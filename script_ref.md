The lscript (extension '.ls') is used to build lsystems in a script-like way. 
The lscript will build the lsystem string pattern based on the rules therein defined.
Or phrased otherwise, it is the blueprint for the lsystem. 

## Terminology

- `lscript`: This is the scripting language used to define l-systems.
- `Operation`: An operation is part of the lscript statement that defines the desired operation for that statement.
- `Axiom`: This is the initial state, string, of the lsystem without any `rules` applies to it.
- `Rule`: A rule defines how a `symbol` is replaces by some other sequence of `symbols`.
- `Symbol`: A symbol is a constant, variable, or `module` in the `alphabet`.
- `Alphabet`: The alphabet is a sequence of `Symbols` generated by the l-system generator who applies `rules` to the `axiom` for `n` `generations`. It defines the recursive generated structure.
- `Module`: A module is defined by `(x, y, n..)`, it may contain recursive expressions. Other way to describe it is as function arguments.
- `Action`: An action is executed when a certain `symbol` occurs.

## Defining the LSystem

When '*' is postfixed it means that this is mandatory to be specified.

```lscript
lsystem Name {
}
```

- **Name** *: [a-z,A-Z]

This defines an lsystem that is named `Name`.

## Statements

Each `lssytem` has a finite number of statements. Where each statement starts with the `operation` and ends by `;`.

There are four `operations`:
- axiom x;
- interpret x as y;
- replace x by y;
- let x = y;

### axiom *

This is the initial state, string, of the lsystem without any `rules` applies to it.

```
axiom "A";
```

### replace

Defines a `rule` which replaces one `symbol` `S` by a sequence of other `symbols` `S..S+N`. 

```
replace <S> by <S..S+N>;
replace(0.5) <S> by <S..S+N>;
```

* Symbols should not be separated by space
* Symbols can be anything, like placeholders, and don't have to be interpreted.
* (0.5) after replace means this rule has a 50% change of being applied.

### interpret

Defines how an symbol `S` is to be interpreted by an action `A(n)`. Where the action `A` implements the behavior. The action accepts 0 or more arguments where each argument is separated by `,`. An argument can be recursive using basic binary expressions with arithmetic operators. 

The `action` is defined in Rust language and will be resolved based on the action name.

```
interpret <S> as A(n);

interpret F as MoveForward(1.0);
interpret + as RoateRight(3.14/2);
interpret - as RotateLeft((2 * 3.14)/(2 - 1));
interpret A as ColorVertex(255, 255, 255);
interpret R as RandomNmr(r(3.14..2*3.14)); // r generates random number within 3.14 <= x < 2*3.14.
```

* Supported operators in actions: +, -, /, *, %
* Can recursively use parameters `()` to scope calculations
* Can use randomize function `r(start..end)`, `start` end `end` are float numbers. The range `start..end` contains all floats with `start <= x < end`. A random number is generated within this range to create variation. 
* Future support: <, >, <=, >=, !=, ==
* Future support: Allow usage of variables defined by `let` statements.


### let

Defines a variable which can be used in the `interpret` `rules`.

## Koch Curve Example

```
lsystem KochCurve {
    axiom F;

    replace F by F+F-F-F+F;
    interpret F as MoveForward(0.1);
    interpret - as RotateLeft(3.14/2);
    interpret + as RotateRight(3.14/2);
}
```

See [wikipedia definition](https://en.wikipedia.org/wiki/L-system#Example_4:_Koch_curve) and compare how this script implements that l-system.
